alias Ecto.Adapters.SQL, as: EctoSQL

if Code.ensure_loaded?(EctoSQL) do
  defmodule Supabase.PostgREST.RLS do
    @moduledoc """
    Helpers for working with PostgreSQL Row Level Security (RLS) policies in Ecto.

    This module provides utilities to set session context for RLS policies when using
    the Ecto schemas generated by `mix supabase.gen.schema`.

    ## RLS Context Approaches

    There are two main approaches for setting RLS context with Ecto:

    ### 1. Transaction-based Context (Recommended)

    Wrap operations in a transaction and set session variables that are automatically
    cleaned up when the transaction completes:

        defmodule MyApp.Repo do
          use Ecto.Repo, otp_app: :my_app

          import Supabase.PostgREST.RLS

          def with_user_context(repo, user_id, fun) do
            transaction(fn ->
              set_rls_context(repo, "request.jwt.claims.sub", user_id)
              fun.()
            end)
          end
        end

        # Usage
        Repo.with_user_context(repo, user_id, fn ->
          Repo.all(MyApp.Accounts.User)
        end)

    ### 2. Helper Function (Simplified)

    Use the `with_user_context/3` helper to wrap operations:

        defmodule MyApp.Accounts do
          import Supabase.PostgREST.RLS

          def list_users(current_user) do
            with_user_context(MyApp.Repo, current_user.id, fn ->
              Repo.all(User)
            end)
          end
        end

    ## Common Supabase RLS Patterns

    Supabase RLS policies commonly use these session variables:

    - `request.jwt.claims.sub` - User ID from JWT
    - `request.jwt.claims.role` - User role from JWT
    - `request.jwt.claims.email` - User email from JWT

    Example policy in your database:

        CREATE POLICY "Users can view their own data"
          ON users FOR SELECT
          USING (id = current_setting('request.jwt.claims.sub')::uuid);

    ## Testing with RLS

    When testing, you may want to bypass RLS policies. PostgreSQL allows bypassing
    RLS when connected as the table owner or a superuser:

        # In test environment, connect as superuser
        config :my_app, MyApp.Repo,
          username: "postgres",
          password: "postgres"

    Or explicitly disable RLS for specific tables in tests:

        ALTER TABLE users DISABLE ROW LEVEL SECURITY;

    ## References

    - [PostgreSQL Row Security Policies](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)
    - [Supabase RLS Documentation](https://supabase.com/docs/guides/database/postgres/row-level-security)
    - [Ecto.Repo Callbacks](https://hexdocs.pm/ecto/Ecto.Repo.html)
    """

    @doc """
    Sets a PostgreSQL session configuration variable for the current transaction.

    This function executes `set_config/3` with the `is_local` parameter set to `true`,
    ensuring the configuration is transaction-scoped and automatically cleared when
    the transaction completes.

    ## Parameters

      * `repo` - The Ecto repository module
      * `key` - The configuration parameter name (e.g., "request.jwt.claims.sub")
      * `value` - The value to set (will be converted to string)

    ## Examples

        # Inside a transaction
        Repo.transaction(fn ->
          set_rls_context(repo, "request.jwt.claims.sub", user.id)
          Repo.all(User)
        end)

        # With custom variable name
        Repo.transaction(fn ->
          set_rls_context(repo, "app.current_tenant", tenant_id)
          Repo.all(from u in User, where: ...)
        end)

    ## Security Considerations

    - Always validate and sanitize the `value` parameter before passing it to this function
    - Never pass user input directly without validation
    - Consider using prepared statements for complex values

    """
    def set_rls_context(repo, key, value) when is_binary(key) do
      value_str = to_string(value)

      EctoSQL.query!(
        repo,
        "SELECT set_config($1, $2, true)",
        [key, value_str]
      )
    end

    @doc """
    Sets the Supabase user ID in the RLS context.

    This is a convenience wrapper around `set_rls_context/3` that sets the
    standard Supabase JWT claims user ID.

    ## Examples

        Repo.transaction(fn ->
          set_user_id(repo, current_user.id)
          Repo.all(User)
        end)

    """
    def set_user_id(repo, user_id) do
      set_rls_context(repo, "request.jwt.claims.sub", user_id)
    end

    @doc """
    Sets the Supabase user role in the RLS context.

    ## Examples

        Repo.transaction(fn ->
          set_user_role(repo, "authenticated")
          Repo.all(User)
        end)

    """
    def set_user_role(repo, role) when is_binary(role) do
      set_rls_context(repo, "request.jwt.claims.role", role)
    end

    @doc """
    Sets multiple RLS context variables at once.

    ## Examples

        Repo.transaction(fn ->
          set_rls_claims(repo, %{
            "request.jwt.claims.sub" => user.id,
            "request.jwt.claims.role" => "authenticated",
            "request.jwt.claims.email" => user.email
          })
          Repo.all(User)
        end)

    """
    def set_rls_claims(repo, claims) when is_map(claims) do
      Enum.each(claims, fn {key, value} ->
        set_rls_context(key, value, repo)
      end)
    end

    @doc """
    Gets the current value of an RLS context variable.

    Returns `nil` if the variable is not set.

    ## Examples

        current_user_id = get_rls_context(MyApp.Repo, "request.jwt.claims.sub")

    """
    def get_rls_context(repo, key) when is_binary(key) do
      case EctoSQL.query(repo, "SELECT current_setting($1, true)", [key]) do
        {:ok, %{rows: [[value]]}} when value != "" -> value
        _ -> nil
      end
    end

    @doc """
    Helper to wrap operations with automatic RLS context from Phoenix assigns.

    This function can be called from your context or controller to automatically
    set RLS context from the current user.

    ## Examples

        defmodule MyApp.Accounts do
          import Supabase.PostgREST.RLS

          def list_users(current_user) do
            {:ok, users} = with_user_context(MyApp.Repo, current_user.id, fn ->
              Repo.all(User)
            end)

            users
          end
        end

        # Or in a Phoenix controller
        defmodule MyAppWeb.UserController do
          import Supabase.PostgREST.RLS

          def index(conn, _params) do
            current_user = conn.assigns.current_user

            {:ok, users} = with_user_context(MyApp.Repo, current_user.id, fn ->
              Repo.all(User)
            end)

            render(conn, :index, users: users)
          end
        end

    """
    def with_user_context(repo, user_id, fun) when is_function(fun, 0) do
      repo.transaction(fn ->
        set_user_id(user_id, repo)
        fun.()
      end)
    end
  end
end
