defmodule Supabase.PostgREST.ParserTest do
  use ExUnit.Case, async: true

  alias Supabase.PostgREST.Parser

  describe "run/1" do
    test "returns empty AST for empty input" do
      assert {:ok, []} = Parser.run("")
    end

    test "returns empty AST for whitespace-only input" do
      assert {:ok, []} = Parser.run("   \n\t  ")
    end

    test "ignores SET statements" do
      input = """
      SET statement_timeout = 0;
      SET lock_timeout = 0;
      SET client_encoding = 'UTF8';
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores SELECT statements" do
      input = """
      SELECT pg_catalog.set_config('search_path', '', false);
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores CREATE SCHEMA statements" do
      input = """
      CREATE SCHEMA IF NOT EXISTS "public";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores ALTER SCHEMA statements" do
      input = """
      ALTER SCHEMA "public" OWNER TO "pg_database_owner";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores COMMENT statements" do
      input = """
      COMMENT ON SCHEMA "public" IS 'standard public schema';
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores ALTER TABLE statements" do
      input = """
      ALTER TABLE "public"."distributors" OWNER TO "postgres";
      ALTER TABLE "public"."distributors" ALTER COLUMN "did" ADD GENERATED BY DEFAULT AS IDENTITY;
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores CREATE SEQUENCE statements" do
      input = """
      CREATE SEQUENCE IF NOT EXISTS "public"."films_id_seq"
          AS integer
          START WITH 1
          INCREMENT BY 1;
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores ALTER SEQUENCE statements" do
      input = """
      ALTER SEQUENCE "public"."films_id_seq" OWNER TO "postgres";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores GRANT statements" do
      input = """
      GRANT USAGE ON SCHEMA "public" TO "postgres";
      GRANT SELECT,INSERT,DELETE ON TABLE "public"."films" TO "anon";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores ALTER DEFAULT PRIVILEGES statements" do
      input = """
      ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores RESET statements" do
      input = """
      RESET ALL;
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "parses CREATE TABLE with columns and constraints" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."distributors" (
          "did" integer NOT NULL,
          "name" character varying(40) NOT NULL,
          "film_id" integer,
          CONSTRAINT "distributors_name_check" CHECK ((("name")::text <> ''::text))
      );
      """

      assert {:ok, [{{"public", "distributors"}, cols}]} = Parser.run(input)
      assert length(cols) == 3
      assert {"did", attrs} = Enum.at(cols, 0)
      assert {:type, "integer"} in attrs
      assert {:null, false} in attrs
    end

    test "parses CREATE TABLE with multiple columns and types" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."films" (
          "id" integer NOT NULL,
          "code" character(5),
          "title" character varying(40) NOT NULL,
          "did" integer NOT NULL,
          "date_prod" date,
          "kind" character varying(10),
          "len" interval hour to minute
      );
      """

      assert {:ok, [{{"public", "films"}, cols}]} = Parser.run(input)
      assert length(cols) == 7

      # Check first column
      assert {"id", id_attrs} = Enum.at(cols, 0)
      assert {:type, "integer"} in id_attrs
      assert {:null, false} in id_attrs

      # Check character type is converted to text
      assert {"code", code_attrs} = Enum.at(cols, 1)
      assert {:type, "string"} in code_attrs

      # Check date type
      assert {"date_prod", date_attrs} = Enum.at(cols, 4)
      assert {:type, "date"} in date_attrs
    end

    test "parses CREATE POLICY statements" do
      input = """
      CREATE POLICY "test_policy" ON "public"."users"
          AS PERMISSIVE FOR SELECT
          TO authenticated
          USING (id = auth.uid());
      """

      assert {:ok, [{"test_policy", opts}]} = Parser.run(input)
      assert {:on, {"public", "users"}} in opts
      assert {:type, :permissive} in opts
      assert {:for, :select} in opts
      assert {:role, "authenticated"} in opts
      assert {:using, using_expr} = List.keyfind(opts, :using, 0)
      assert is_binary(using_expr)
    end

    test "parses CREATE POLICY with WITH CHECK clause" do
      input = """
      CREATE POLICY "users_insert_policy" ON "public"."users"
          FOR INSERT
          TO authenticated
          WITH CHECK (auth.uid() = id);
      """

      assert {:ok, [{"users_insert_policy", opts}]} = Parser.run(input)
      assert {:on, {"public", "users"}} in opts
      assert {:for, :insert} in opts
      assert {:role, "authenticated"} in opts
      assert {:with_check, check_expr} = List.keyfind(opts, :with_check, 0)
      assert is_binary(check_expr)
      assert check_expr =~ "auth.uid"
    end

    test "parses CREATE POLICY with both USING and WITH CHECK" do
      input = """
      CREATE POLICY "users_update_policy" ON "public"."users"
          FOR UPDATE
          TO authenticated
          USING (auth.uid() = id)
          WITH CHECK (auth.uid() = id);
      """

      assert {:ok, [{"users_update_policy", opts}]} = Parser.run(input)
      assert {:on, {"public", "users"}} in opts
      assert {:for, :update} in opts
      assert {:role, "authenticated"} in opts
      assert {:using, using_expr} = List.keyfind(opts, :using, 0)
      assert {:with_check, check_expr} = List.keyfind(opts, :with_check, 0)
      assert is_binary(using_expr)
      assert is_binary(check_expr)
    end

    test "parses CREATE POLICY with RESTRICTIVE type" do
      input = """
      CREATE POLICY "admin_only" ON "public"."admin_table"
          AS RESTRICTIVE FOR ALL
          TO authenticated
          USING (role = 'admin');
      """

      assert {:ok, [{"admin_only", opts}]} = Parser.run(input)
      assert {:on, {"public", "admin_table"}} in opts
      assert {:type, :restrictive} in opts
      assert {:for, :all} in opts
      assert {:role, "authenticated"} in opts
    end

    test "parses CREATE POLICY for DELETE action" do
      input = """
      CREATE POLICY "users_delete_policy" ON "public"."users"
          FOR DELETE
          TO authenticated
          USING (auth.uid() = id);
      """

      assert {:ok, [{"users_delete_policy", opts}]} = Parser.run(input)
      assert {:for, :delete} in opts
    end

    test "parses CREATE POLICY with table name without schema" do
      input = """
      CREATE POLICY "simple_policy" ON users
          FOR SELECT
          USING (true);
      """

      assert {:ok, [{"simple_policy", opts}]} = Parser.run(input)
      assert {:on, "users"} in opts
      assert {:for, :select} in opts
    end

    test "parses multiple CREATE POLICY statements" do
      input = """
      CREATE POLICY "policy_one" ON "public"."users"
          FOR SELECT
          USING (true);

      CREATE POLICY "policy_two" ON "public"."posts"
          FOR INSERT
          WITH CHECK (author_id = auth.uid());
      """

      assert {:ok, policies} = Parser.run(input)
      assert length(policies) == 2

      assert [{"policy_one", opts1}, {"policy_two", opts2}] = policies
      assert {:on, {"public", "users"}} in opts1
      assert {:for, :select} in opts1

      assert {:on, {"public", "posts"}} in opts2
      assert {:for, :insert} in opts2
    end

    test "parses CREATE TABLE and CREATE POLICY together" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."users" (
          "id" uuid PRIMARY KEY,
          "email" text NOT NULL
      );

      CREATE POLICY "users_select_policy" ON "public"."users"
          FOR SELECT
          USING (auth.uid() = id);
      """

      assert {:ok, ast} = Parser.run(input)
      assert length(ast) == 2

      # First should be table
      assert [{{"public", "users"}, cols}, {"users_select_policy", policy_opts}] = ast
      assert length(cols) == 2

      # Second should be policy
      assert {:on, {"public", "users"}} in policy_opts
      assert {:for, :select} in policy_opts
    end

    test "parses mixed statements from real dump, extracting only CREATE TABLE" do
      input = """
      SET statement_timeout = 0;
      CREATE SCHEMA IF NOT EXISTS "public";
      ALTER SCHEMA "public" OWNER TO "pg_database_owner";

      CREATE TABLE IF NOT EXISTS "public"."distributors" (
          "did" integer NOT NULL,
          "name" character varying(40) NOT NULL
      );

      ALTER TABLE "public"."distributors" OWNER TO "postgres";
      GRANT USAGE ON SCHEMA "public" TO "postgres";
      """

      assert {:ok, [{{"public", "distributors"}, cols}]} = Parser.run(input)
      assert length(cols) == 2
    end

    test "handles case insensitivity" do
      input = """
      create table if not exists "public"."test" (
          "id" integer not null
      );
      """

      assert {:ok, [{{"public", "test"}, cols}]} = Parser.run(input)
      assert length(cols) == 1
      assert {"id", attrs} = Enum.at(cols, 0)
      assert {:type, "integer"} in attrs
      assert {:null, false} in attrs
    end

    test "handles extra whitespace and newlines" do
      input = """


      SET    statement_timeout   =    0  ;


      CREATE   SCHEMA   IF   NOT   EXISTS   "public"  ;


      """

      assert {:ok, []} = Parser.run(input)
    end

    test "parses ALTER TABLE ADD CONSTRAINT PRIMARY KEY" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."users" (
          "id" uuid NOT NULL,
          "email" text NOT NULL
      );

      ALTER TABLE ONLY "public"."users"
          ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");
      """

      assert {:ok, [{{"public", "users"}, cols}]} = Parser.run(input)
      assert length(cols) == 2

      assert {"id", id_attrs} = Enum.at(cols, 0)
      assert {:primary, true} in id_attrs
      assert {:type, "binary_id"} in id_attrs
      assert {:null, false} in id_attrs
    end

    test "parses multiple tables with primary keys from ALTER TABLE" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."distributors" (
          "did" integer NOT NULL,
          "name" character varying(40) NOT NULL
      );

      CREATE TABLE IF NOT EXISTS "public"."films" (
          "id" integer NOT NULL,
          "title" text NOT NULL
      );

      ALTER TABLE ONLY "public"."distributors"
          ADD CONSTRAINT "distributors_pkey" PRIMARY KEY ("did");

      ALTER TABLE ONLY "public"."films"
          ADD CONSTRAINT "films_pkey" PRIMARY KEY ("id");
      """

      assert {:ok, tables} = Parser.run(input)
      assert length(tables) == 2

      # Check distributors table
      assert {{"public", "distributors"}, dist_cols} = Enum.at(tables, 0)
      assert {"did", did_attrs} = Enum.find(dist_cols, fn {name, _} -> name == "did" end)
      assert {:primary, true} in did_attrs

      # Check films table
      assert {{"public", "films"}, film_cols} = Enum.at(tables, 1)
      assert {"id", id_attrs} = Enum.find(film_cols, fn {name, _} -> name == "id" end)
      assert {:primary, true} in id_attrs
    end

    test "parses table without ALTER TABLE primary key" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."users" (
          "id" uuid NOT NULL,
          "email" text NOT NULL
      );
      """

      assert {:ok, [{{"public", "users"}, cols}]} = Parser.run(input)
      assert length(cols) == 2

      # id should NOT have primary flag
      assert {"id", id_attrs} = Enum.at(cols, 0)
      refute {:primary, true} in id_attrs
    end

    test "parses inline PRIMARY KEY constraint" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."users" (
          "id" uuid PRIMARY KEY,
          "email" text NOT NULL
      );
      """

      assert {:ok, [{{"public", "users"}, cols}]} = Parser.run(input)
      assert length(cols) == 2

      assert {"id", id_attrs} = Enum.at(cols, 0)
      assert {:primary, true} in id_attrs
    end

    test "parses real dump.sql structure" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."distributors" (
          "did" integer NOT NULL,
          "name" character varying(40) NOT NULL,
          "film_id" integer,
          CONSTRAINT "distributors_name_check" CHECK ((("name")::"text" <> ''::"text"))
      );

      ALTER TABLE "public"."distributors" OWNER TO "postgres";

      ALTER TABLE ONLY "public"."distributors"
          ADD CONSTRAINT "distributors_pkey" PRIMARY KEY ("did");
      """

      assert {:ok, [{{"public", "distributors"}, cols}]} = Parser.run(input)
      assert length(cols) == 3

      assert {"did", did_attrs} = Enum.find(cols, fn {name, _} -> name == "did" end)
      assert {:primary, true} in did_attrs
      assert {:type, "integer"} in did_attrs
      assert {:null, false} in did_attrs
    end
  end
end
