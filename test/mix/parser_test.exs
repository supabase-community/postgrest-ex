defmodule Supabase.PostgREST.ParserTest do
  use ExUnit.Case, async: true

  alias Supabase.PostgREST.Parser

  describe "run/1" do
    test "returns empty AST for empty input" do
      assert {:ok, []} = Parser.run("")
    end

    test "returns empty AST for whitespace-only input" do
      assert {:ok, []} = Parser.run("   \n\t  ")
    end

    test "ignores SET statements" do
      input = """
      SET statement_timeout = 0;
      SET lock_timeout = 0;
      SET client_encoding = 'UTF8';
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores SELECT statements" do
      input = """
      SELECT pg_catalog.set_config('search_path', '', false);
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores CREATE SCHEMA statements" do
      input = """
      CREATE SCHEMA IF NOT EXISTS "public";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores ALTER SCHEMA statements" do
      input = """
      ALTER SCHEMA "public" OWNER TO "pg_database_owner";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores COMMENT statements" do
      input = """
      COMMENT ON SCHEMA "public" IS 'standard public schema';
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores ALTER TABLE statements" do
      input = """
      ALTER TABLE "public"."distributors" OWNER TO "postgres";
      ALTER TABLE "public"."distributors" ALTER COLUMN "did" ADD GENERATED BY DEFAULT AS IDENTITY;
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores CREATE SEQUENCE statements" do
      input = """
      CREATE SEQUENCE IF NOT EXISTS "public"."films_id_seq"
          AS integer
          START WITH 1
          INCREMENT BY 1;
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores ALTER SEQUENCE statements" do
      input = """
      ALTER SEQUENCE "public"."films_id_seq" OWNER TO "postgres";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores GRANT statements" do
      input = """
      GRANT USAGE ON SCHEMA "public" TO "postgres";
      GRANT SELECT,INSERT,DELETE ON TABLE "public"."films" TO "anon";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores ALTER DEFAULT PRIVILEGES statements" do
      input = """
      ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "ignores RESET statements" do
      input = """
      RESET ALL;
      """

      assert {:ok, []} = Parser.run(input)
    end

    test "parses CREATE TABLE with columns and constraints" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."distributors" (
          "did" integer NOT NULL,
          "name" character varying(40) NOT NULL,
          "film_id" integer,
          CONSTRAINT "distributors_name_check" CHECK ((("name")::text <> ''::text))
      );
      """

      assert {:ok, [{{"public", "distributors"}, cols}]} = Parser.run(input)
      assert length(cols) == 3
      assert {"did", attrs} = Enum.at(cols, 0)
      assert {:type, "integer"} in attrs
      assert {:null, false} in attrs
    end

    test "parses CREATE TABLE with multiple columns and types" do
      input = """
      CREATE TABLE IF NOT EXISTS "public"."films" (
          "id" integer NOT NULL,
          "code" character(5),
          "title" character varying(40) NOT NULL,
          "did" integer NOT NULL,
          "date_prod" date,
          "kind" character varying(10),
          "len" interval hour to minute
      );
      """

      assert {:ok, [{{"public", "films"}, cols}]} = Parser.run(input)
      assert length(cols) == 7

      # Check first column
      assert {"id", id_attrs} = Enum.at(cols, 0)
      assert {:type, "integer"} in id_attrs
      assert {:null, false} in id_attrs

      # Check character type is converted to text
      assert {"code", code_attrs} = Enum.at(cols, 1)
      assert {:type, "string"} in code_attrs

      # Check date type
      assert {"date_prod", date_attrs} = Enum.at(cols, 4)
      assert {:type, "date"} in date_attrs
    end

    test "parses CREATE POLICY statements" do
      input = """
      CREATE POLICY "test_policy" ON "public"."users"
          AS PERMISSIVE FOR SELECT
          TO authenticated
          USING (id = auth.uid());
      """

      assert {:ok, [{"test_policy", opts}]} = Parser.run(input)
      assert {:on, {"public", "users"}} in opts
      assert {:type, :permissive} in opts
      assert {:for, :select} in opts
      assert {:role, "authenticated"} in opts
      assert {:using, using_expr} = List.keyfind(opts, :using, 0)
      assert is_binary(using_expr)
    end

    test "parses mixed statements from real dump, extracting only CREATE TABLE" do
      input = """
      SET statement_timeout = 0;
      CREATE SCHEMA IF NOT EXISTS "public";
      ALTER SCHEMA "public" OWNER TO "pg_database_owner";

      CREATE TABLE IF NOT EXISTS "public"."distributors" (
          "did" integer NOT NULL,
          "name" character varying(40) NOT NULL
      );

      ALTER TABLE "public"."distributors" OWNER TO "postgres";
      GRANT USAGE ON SCHEMA "public" TO "postgres";
      """

      assert {:ok, [{{"public", "distributors"}, cols}]} = Parser.run(input)
      assert length(cols) == 2
    end

    test "handles case insensitivity" do
      input = """
      create table if not exists "public"."test" (
          "id" integer not null
      );
      """

      assert {:ok, [{{"public", "test"}, cols}]} = Parser.run(input)
      assert length(cols) == 1
      assert {"id", attrs} = Enum.at(cols, 0)
      assert {:type, "integer"} in attrs
      assert {:null, false} in attrs
    end

    test "handles extra whitespace and newlines" do
      input = """


      SET    statement_timeout   =    0  ;


      CREATE   SCHEMA   IF   NOT   EXISTS   "public"  ;


      """

      assert {:ok, []} = Parser.run(input)
    end
  end
end
